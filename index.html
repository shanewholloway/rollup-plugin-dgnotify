<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='utf-8' />
  <meta name='viewport' content='width=device-width, initial-scale=1'>
  <title>Datagram Notify Rollup Plugin</title>

  <link rel='icon' href='data:image/png;base64,' />
  <link rel='stylesheet' crossorigin='anonymous' href='https://cdn.jsdelivr.net/npm/picnic@6.5.1/picnic.min.css' />
  <style>
    body { margin: 2em 2em; }
    .dg_good { color: green; }
    .dg_error { color: red; }
    .dg>time { margin-right: 1em; }

    .connecting { border-color: 3px dashed blue; }
    .connected { border-color: 1px dotted green; }
  </style>

  <script crossorigin='anonymous' src='https://cdn.jsdelivr.net/npm/superfine@7.0.0/dist/superfine.min.js'></script>
</head>

<body>
  <main>
    <h1>Datagram Notify Rollup Plugin</h1>
    <div>
      <button id='enable_speech'>
        Enable Speech Notifications
      </button>
      <div>
        <label>Datagram Relay Host</label>
        <input name='dg_relay_host' value='http://127.0.0.1:8098' />
        <select id='dg_relay_host_select'></select>
      </div>
    </div>

    <section id='app'>
    </section>
  </main>

  <script type=module>
    window.addEventListener('qsrv', evt => evt.preventDefault())

    document.querySelector('#enable_speech')
      .addEventListener('click', evt=>{
        sayit(`Speech notifications ready`) 
        evt.target.parentNode.removeChild(evt.target)
      })

    let voice
    window.init_voices = async function init_voices() {
      for (let i=0; i<10; i++) {
        const voices = speechSynthesis.getVoices()
          .filter(voice => voice.lang.startsWith('en-'))
          .sort((a,b) => a.name.localeCompare(b.name))

        if (0 !== voices.length) {
          voice = voices[location.port ? 0 : 1]
          return voices
        }
        await new Promise(y => setTimeout(y,10))
      }
    }

    window.sayit = async function sayit(msg, force) {
      if (!force && speechSynthesis.speaking)
        return console.log('(already speaking):', msg)

      if (undefined === voice)
        await init_voices()

      console.log('(say):', msg)
      const utter = new SpeechSynthesisUtterance(msg)
      utter.voice = voice
      speechSynthesis.speak(utter)
    }

    let _p_refresh
    function refresh_info(info) {
      if (undefined !== _p_refresh)
        return _p_refresh

      return _p_refresh = Promise.resolve(info)
        .then(refresh_app)
        .finally(() => {_p_refresh = undefined})
    }

    {
      const dg_relay_info = new Map()
      refresh_info(dg_relay_info)

      const el_dg_relay_host = document.querySelector('[name=dg_relay_host]')
      {
        const {hostname} = window.location
        const ip_hostname = hostname.split('.').map(v => parseInt(v)).slice(0,4).join('.')
        if (ip_hostname == hostname)
          el_dg_relay_host.value = `http://${ip_hostname}:8098`
      }


      let es=null
      function update_event_source() {
        if (es) { es.close(); es = null }
        console.log('el_dg_relay_host:', el_dg_relay_host.value)

        el_dg_relay_host.className = 'connecting'
        const dg_relay_host = el_dg_relay_host.value
        es = new EventSource(`${dg_relay_host}/dg_relay?8099`)
        es.onmessage = on_dg_msg
        es.onopen = function() {
          el_dg_relay_host.className = 'connected'
          let cur = JSON.parse(localStorage.getItem('dg_relay_hosts') || '[]')
          const idx = cur.indexOf(dg_relay_host)
          if (-1 !== idx) cur[idx] = null
          cur.unshift(dg_relay_host)
          cur = cur.filter(Boolean)
          console.log({cur})
          localStorage.setItem('dg_relay_hosts', JSON.stringify(cur))
        }
      }
      el_dg_relay_host.addEventListener('change', update_event_source)
      Promise.resolve().then(update_event_source)

      function on_dg_msg(evt) {
        const msg = JSON.parse(evt.data)
        msg.ts = new Date()
        dg_relay_info.set(msg.id.cwd, msg)
        refresh_info(dg_relay_info)

        if (msg.err) {
          try {
            sayit(`New error at ${msg.id.cwd}`)
          } catch (err) {
            console.error(err)
          }
        }
      }
    }


    const {h} = superfine
    const bind_render_on = node => view => node = superfine.patch(node, view)
    const render_app = bind_render_on(document.getElementById('app'))

    function refresh_app(dg_relay_info) {
      const parts = []
      for (const msg of dg_relay_info.values()) {
        parts.push(_render_dg_article(msg))
      }
      render_app(h('section', {}, parts))
    }

    function _render_dg_article(msg) {
      return h('li', {className: `dg ${msg.err ? 'dg_error' : 'dg_good'}`},
        h('time', {datetime: msg.ts.toISOString()}, `[${msg.ts.toLocaleTimeString()}]`),
        h('b', {}, `${msg.id.cwd}`),
        msg.err && _render_dg_err(msg.err, msg)
      )
    }

    function _render_dg_err(err) {
      const by_err_key = {
        _: v => JSON.stringify(v, null, 4),
        frame: v => ['', ... v.trim().split('\n')].join('\n    '),
      }

      const sz_err = Object.entries(err)
        .map(([k,v]) => `${k}: ${(by_err_key[k] || by_err_key._)(v)}`)
        .join('\n')

      return h('pre', {}, h('output', {}, sz_err))
    }

  </script>
</body>
</html>
